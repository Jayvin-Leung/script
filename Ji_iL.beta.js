var Ji_iL = (function() {
	'use strict';

	const NODE_TYPE = { ELEMENT: 1, ATTRIBUTE: 2, TEXT: 3, NOTE: 8, DOCUMENT: 9 };

	const MD_CHARACTER = {
		LINE_BREAK: { SPACE: '  ', RETURN: '\n' },
		BOLD: { ASTERISK: '**', UNDERSCORE: '__' },
		ITALIC: { ASTERISK: '*', UNDERSCORE: '_' },
		UNDERLINED: { U_TAG: {START: '<u>', END: '</u>'} },
		STRIKETHROUGH: { TILDE: '~~' },
		UNORDERED_LIST: { HYPHEN: '-', PLUS_SIGN: '+', ASTERISK: '*' },
		CODE: { BACKTICK_QUOTES: '```' + '\n', TILDE: '~~~' + '\n' }
	};

	const CONFIG = {
		CATALOG: {
			STYLE: {
				_1: 'È£éÊ†º‰∏Ä',
				_2: 'È£éÊ†º‰∫å',
				_3: 'È£éÊ†º‰∏â',
				_4: 'È£éÊ†ºÂõõ',
				_5: 'È£éÊ†º‰∫î',
				_6: 'È£éÊ†ºÂÖ≠'
			},
			LINE_BREAK: {
				SPACE: '  ',
				RETURN: '\n'
			}
		},
		TITLE: {
			PATTERN: {
				_1: 'P{x} üì∫ {xxx}',
				_2: 'Á¨¨ {x} ÈõÜÔºö„Ää{xxx}„Äã'
			},
			LEVEL: {
				_1: '#',
				_2: '##',
				_3: '###',
				_4: '####',
				_5: '#####',
				_6: '######',
			}
		},
		NOTE: {
			ESCAPE_LEVEL: {
				ALL: 'all',
				RULE: 'rule',
				NONE: 'none'
			},
			ESCAPE_RULE: {
				// \
				BACKSLASH: {
					REGEXP: /\\/g,
					REPLACEMENT: '\\\\',
					IS_HEAD: false,
					IS_LOOP: false
				},
				// `
				BACKTICK: {
					REGEXP: /`/g,
					REPLACEMENT: '\\`',
					IS_HEAD: false,
					IS_LOOP: false
				},
				// *
				ASTERISK: {
					REGEXP: /\*/g,
					REPLACEMENT: '\\*',
					IS_HEAD: false,
					IS_LOOP: false
				},
				// _
				UNDERSCORE: {
					REGEXP: /_/g,
					REPLACEMENT: '\\_',
					IS_HEAD: false,
					IS_LOOP: false
				},
				/*
				// {
				CURLY_BRACE_LEFT: {
					REGEXP: /{/g,
					REPLACEMENT: '\\{',
					IS_HEAD: false,
					IS_LOOP: false
				},
				// }
				CURLY_BRACE_RIGHT: {
					REGEXP: /}/g,
					REPLACEMENT: '\\}',
					IS_HEAD: false,
					IS_LOOP: false
				},
				// (
				PARENTHESE_LEFT: {
					REGEXP: /\(/g,
					REPLACEMENT: '\\(',
					IS_HEAD: false,
					IS_LOOP: false
				},
				// )
				PARENTHESE_RIGHT: {
					REGEXP: /\)/g,
					REPLACEMENT: '\\)',
					IS_HEAD: false,
					IS_LOOP: false
				},
				*/
				// [
				SQUARE_BRACKET_LEFT: {
					REGEXP: /\[/g,
					REPLACEMENT: '\\[',
					IS_HEAD: false,
					IS_LOOP: false
				},
				// ]
				SQUARE_BRACKET_RIGHT: {
					REGEXP: /\]/g,
					REPLACEMENT: '\\]',
					IS_HEAD: false,
					IS_LOOP: false
				},
				// #
				HASK_MARK_TITLE: {
					REGEXP: /^(#{1,6} )/g,
					REPLACEMENT: '\\$1',
					IS_HEAD: true,
					IS_LOOP: false
				},
				HASK_MARK: {
					REGEXP: /(?<= +)(#[a-zA-Z\u4e00-\u9fa5])/g,
					REPLACEMENT: '\\$1',
					IS_HEAD: false,
					IS_LOOP: false
				},
				// +
				PLUS_SIGN: {
					REGEXP: /(?<=^ {0,3})\+ /g,
					REPLACEMENT: '\\+ ',
					IS_HEAD: true,
					IS_LOOP: false
				},
				// -
				HYPHEN: {
					REGEXP: /(?<=^ {0,3})- /g,
					REPLACEMENT: '\\- ',
					IS_HEAD: true,
					IS_LOOP: false
				},
				// .
				DOT: {
					REGEXP: /(?<=^ {0,3})(\d+)\. /g,
					REPLACEMENT: '$1\\\. ',
					IS_HEAD: true,
					IS_LOOP: false
				},
				// !
				EXCLAMATION_MARK: {
					REGEXP: /!\[/g,
					REPLACEMENT: '\\!\\[',
					IS_HEAD: false,
					IS_LOOP: false
				},
				// <
				ANGLE_BRACKET_LEFT: {
					REGEXP: /<([a-zA-Z]+)/g,
					REPLACEMENT: '\\<$1',
					IS_HEAD: false,
					IS_LOOP: false
				},
				// >
				ANGLE_BRACKET_RIGHT: {
					REGEXP: /(?<=^ {0,3})>/g,
					REPLACEMENT: '\\>',
					IS_HEAD: true,
					IS_LOOP: false
				},
				// ^
				CIRCUMFLEX: {
					REGEXP: /(?<= +)(\^[a-zA-Z0-9]+$)/g,
					REPLACEMENT: '\\$1',
					IS_HEAD: false,
					IS_LOOP: false
				},
				// ~
				TILDE_CODE: {
					REGEXP: /(?<=^ {0,3})(~~~)/g,
					REPLACEMENT: '\\$1',
					IS_HEAD: true,
					IS_LOOP: false
				},
				TILDE: {
					REGEXP: /(?<=[^\\])((~~)+)(?=[^ |~])/g,
					REPLACEMENT: '\\$1',
					IS_HEAD: false,
					IS_LOOP: true
				},
				// =
				EQUAL_SIGN_HEAD: {
					REGEXP: /(?<=^ {0,3})(=+)/g,
					REPLACEMENT: '\\$1',
					IS_HEAD: true,
					IS_LOOP: false
				},
				EQUAL_SIGN: {
					REGEXP: /(?<=[^\\])((==)+)(?=[^ |=])/g,
					REPLACEMENT: '\\$1',
					IS_HEAD: false,
					IS_LOOP: true
				},
				// $
				DOLLAR_SIGN: {
					REGEXP: /\$/g,
					REPLACEMENT: '\\$',
					IS_HEAD: false,
					IS_LOOP: false
				}
			}
		}
	}

	const DEFAULT_CONFIG = {
		IS_ONLY_CURR: false,
		CATALOG: {
			STYLE: CONFIG.CATALOG.STYLE._1,
			LINE_BREAK: CONFIG.CATALOG.LINE_BREAK.SPACE
		},
		TITLE: {
			PATTERN: CONFIG.TITLE.PATTERN._1,
			LEVEL: CONFIG.TITLE.LEVEL._2
		},
		NOTE: {
			ESCAPE_LEVEL: CONFIG.NOTE.ESCAPE_LEVEL.RULE,
			ESCAPE_STYLE: {
				LINE_BREAK: MD_CHARACTER.LINE_BREAK.RETURN,
				BOLD: MD_CHARACTER.BOLD.ASTERISK,
				ITALIC: MD_CHARACTER.ITALIC.ASTERISK,
				UNDERLINED: MD_CHARACTER.UNDERLINED.U_TAG,
				STRIKETHROUGH: MD_CHARACTER.STRIKETHROUGH.TILDE,
				LIST: MD_CHARACTER.UNORDERED_LIST.HYPHEN,
				CODE: MD_CHARACTER.CODE.BACKTICK_QUOTES
			}
		},
		IS_WIKI: false,
		IS_SEPARATE: false,
		IS_COMPRESSION: false
	};

	const API = {
		'/view': 'https://api.bilibili.com/x/web-interface/view',
		'/view/detail': 'https://api.bilibili.com/x/web-interface/view/detail'
	};

	var videoInfo = {};
	var setting = {};


	function isOpenBiliBili() {
		if (!window.location.href.includes('bilibili.com')) {
			alert("ËØ∑ËøõÂÖ•BÁ´ôÂêéÂÜçÈáçËØï");
			throw 'bilibili is not opened';
		}
	}

	function isOpenVideo() {
		let bvid = window.location.href.match(/(?<=bilibili.com\/video\/)(BV|av)[a-zA-Z0-9]+(?=[\/\?])?/g);
		return { isOpenVideo: bvid ? true : false, bvid: bvid ? bvid[0] : '' };
	}

	function isOpenNote(isOpenVideo, bvid, bv) {
		if (!isOpenVideo) return { isOpenNote: false, editor: null };
		if (bv && bv != bvid) return { isOpenNote: false, editor: null };
		//let editor = document.querySelector(".active-note");
		//editor = editor ? editor.querySelector(".ql-editor") : null;
		//let ion = editor && !editor.classList.contains("ql-blank");
		let editor = document.querySelector(".ql-editor");
		let ion = editor ? true : false;
		return { isOpenNote: ion, editor: editor };
	}

	function getVideoInfo(isOpenVideo, bvid, bv) {
		if(bv) {
			bvid = bv;
		} else {
			if (!isOpenVideo) {
				bvid = prompt("ËØ∑ËæìÂÖ•ËßÜÈ¢ëÁöÑBVÂè∑Ôºö");
				if (bvid == null) throw 'close input';
				if (!bvid || !/^(BV|av)[a-zA-Z0-9]+$/g.test(bvid)) {
					alert("ËßÜÈ¢ëBVÂè∑ËæìÂÖ•ÊúâËØØÔºåËØ∑ÈáçËØï");
					throw 'input invalid value';
				}
			}
		}

		let req = new Request(API['/view'], { bvid: bvid });
		let res = req.get();
		req.close();

		try {
			let data = JSON.parse(res).data;
			let isSeason = data.ugc_season ? true : false;
			let collection = isSeason ? document.querySelector('.first-line-left a') : null;
			let collectionUrl = collection ? collection.href : '';
			return {
				url: 'https://www.bilibili.com/video/' + bvid,
				bvid: data.bvid,
				aid: data.aid,
				pic: data.pic,
				title: data.title,
				desc: data.desc,
				ctime: new Date(data.ctime * 1000).toLocaleString(),
				pubdate: new Date(data.pubdate * 1000).toLocaleString(),
				name: data.owner.name,
				pages: data.pages,
				season: data.ugc_season,
				count: isSeason ? data.ugc_season.ep_count : data.videos,
				type: isSeason ? 3 : (data.videos > 1 ? 2 : 1),
				collectionUrl: collectionUrl
			};
		} catch(e) {
			alert("ËØ∑Ê±ÇBÁ´ôËßÜÈ¢ë‰ø°ÊÅØÊúâËØØÔºåËØ∑Á®çÂêéÈáçËØï");
			throw 'response parse error, e:' + e;
		}
	}

	function getOption(isOpenNote) {
		let selector = {
			'ioc': () => {
				return !confirm("„ÄêÂêàÈõÜÔºöÂÖ±" + videoInfo.count + "‰∏™ËßÜÈ¢ë„ÄëÊòØÂê¶‰∏ãËΩΩÂÖ®ÈÉ®Ôºü\n" 
								+ "Á°ÆËÆ§ÔºöÊòØÔºàÊàëÂÖ®ÈÉΩË¶ÅÔºâ\n" 
								+ "ÂèñÊ∂àÔºöÂê¶ÔºàÂè™Ë¶ÅÂΩìÂâçÊàñÊåáÂÆöËøô‰∏™Ôºâ");
			},
			'ikd': () => {
				return confirm("ÊòØÂê¶‰øùÊåÅÈªòËÆ§ÈÖçÁΩÆÔºü\n" 
								+ "Á°ÆËÆ§ÔºöÊòØÔºàË∑≥ËøáËá™ÂÆö‰πâÈÖçÁΩÆÔºâ\n" 
								+ "ÂèñÊ∂àÔºöÂê¶ÔºàËøõÂÖ•Ëá™ÂÆö‰πâÈÖçÁΩÆÔºâ");
			},
			'cs': () => {
				return prompt("ËØ∑ÈÄâÊã©ÊÉ≥Ë¶ÅÊõ¥Êç¢ÁöÑÊ∏ÖÂçïÈ£éÊ†ºÔºö\n" 
							+ "[È£éÊ†º‰∏Ä]ÔºöÂºïÁî®ÂùóÂåÖË£π + todoÂàóË°®ÔºàÈªòËÆ§Ôºâ\n" 
							+ "[È£éÊ†º‰∫å]ÔºöÂºïÁî®ÂùóÂåÖË£π + Êó†Â∫èÂàóË°®\n" 
							+ "[È£éÊ†º‰∏â]ÔºöÂºïÁî®ÂùóÂåÖË£π\n" 
							+ "[È£éÊ†ºÂõõ]Ôºö‰∏ä‰∏ãÂàÜÂâ≤Á∫øÂåÖË£π + todoÂàóË°®\n" 
							+ "[È£éÊ†º‰∫î]Ôºö‰∏ä‰∏ãÂàÜÂâ≤Á∫øÂåÖË£π + Êó†Â∫èÂàóË°®\n" 
							+ "[È£éÊ†ºÂÖ≠]Ôºö‰∏ä‰∏ãÂàÜÂâ≤Á∫øÂåÖË£π", DEFAULT_CONFIG.CATALOG.STYLE);
			},
			'cbr': () => {
				let cbr = prompt("ËØ∑ÈÄâÊã©Ê∏ÖÂçï‰∏≠ÁöÑÊç¢Ë°åÊñπÂºèÔºö\n" 
								+ "[\\n]ÔºöÁ©∫Â§ö‰∏ÄË°å\n" 
								+ "[  ]Ôºö‰∏§‰∏™Á©∫Ê†ºÔºàÈªòËÆ§Ôºâ", DEFAULT_CONFIG.CATALOG.LINE_BREAK);
				return typeof cbr == 'string' ? cbr.replace(/\\+n/g, "\n") : null;
			},
			'tp': () => {
				return prompt("ËØ∑ËæìÂÖ•Ê∏ÖÂçïÂíåÁ¨îËÆ∞ÁöÑÂàÜÈõÜÊ†áÈ¢òÊ®°ÂºèÔºö\n" 
							+ " Á§∫‰æãÔºöÁ¨¨ {x} ÈõÜÔºö„Ää{xxx}„Äã\n" 
							+ "  {x}ÔºöÈõÜÊï∞\n" 
							+ "{xxx}ÔºöÂàÜÈõÜÊ†áÈ¢ò", DEFAULT_CONFIG.TITLE.PATTERN);
			},
			'tl': () => {
				return prompt("ËØ∑ÈÄâÊã©Á¨îËÆ∞ÁöÑÂàÜÈõÜÊ†áÈ¢òÁ∫ßÂà´Ôºö\n" 
							+ "[#]Ôºö‰∏ÄÁ∫ßÊ†áÈ¢ò\n" 
							+ "[##]Ôºö‰∫åÁ∫ßÊ†áÈ¢òÔºàÈªòËÆ§Ôºâ\n" 
							+ "[###]Ôºö‰∏âÁ∫ßÊ†áÈ¢ò\n" 
							+ "[####]ÔºöÂõõÁ∫ßÊ†áÈ¢ò\n" 
							+ "[#####]Ôºö‰∫îÁ∫ßÊ†áÈ¢ò\n" 
							+ "[######]ÔºöÂÖ≠Á∫ßÊ†áÈ¢ò", DEFAULT_CONFIG.TITLE.LEVEL);
			},
			'nbr': () => {
				let nbr = prompt("ËØ∑ÈÄâÊã©‰∏™‰∫∫Á¨îËÆ∞ÁöÑÊç¢Ë°åÊñπÂºèÔºö\n" 
								+ "[\\n]ÔºöÁ©∫Â§ö‰∏ÄË°åÔºàÈªòËÆ§Ôºâ\n" 
								+ "[  ]Ôºö‰∏§‰∏™Á©∫Ê†º", "\\n");
				return typeof nbr == 'string' ? nbr.replace(/\\+n/g, "\n") : null;
			},
			'b': () => {
				return prompt("ËØ∑ÈÄâÊã©‰∏™‰∫∫Á¨îËÆ∞ÁöÑÂä†Á≤óÊñπÂºèÔºö\n" 
							+ "[**]Ôºö‰∏§‰∏™ÊòüÂè∑ÔºàÈªòËÆ§Ôºâ\n" 
							+ "[__]Ôºö‰∏§Êù°‰∏ãÂàíÁ∫ø", DEFAULT_CONFIG.NOTE.ESCAPE_STYLE.BOLD);
			},
			'i': () => {
				return prompt("ËØ∑ÈÄâÊã©‰∏™‰∫∫Á¨îËÆ∞ÁöÑÊñú‰ΩìÊñπÂºèÔºö\n" 
							+ "[*]Ôºö‰∏Ä‰∏™ÊòüÂè∑ÔºàÈªòËÆ§Ôºâ\n" 
							+ "[_]Ôºö‰∏ÄÊù°‰∏ãÂàíÁ∫ø", DEFAULT_CONFIG.NOTE.ESCAPE_STYLE.ITALIC);
			},
			'li': () => {
				return prompt("ËØ∑ÈÄâÊã©‰∏™‰∫∫Á¨îËÆ∞ÁöÑÊó†Â∫èÂàóË°®‰∏≠Â∞èÂúÜÁÇπÁöÑÊñπÂºèÔºö\n" 
							+ "[-]Ôºö‰∏Ä‰∏™ÂáèÂè∑ÔºàÈªòËÆ§Ôºâ\n" 
							+ "[+]Ôºö‰∏Ä‰∏™Âä†Âè∑\n" 
							+ "[*]Ôºö‰∏Ä‰∏™ÊòüÂè∑", DEFAULT_CONFIG.NOTE.ESCAPE_STYLE.LIST);
			},
			'code': () => {
				return prompt("ËØ∑ÈÄâÊã©‰∏™‰∫∫Á¨îËÆ∞ÁöÑ‰ª£Á†ÅÂùóÊñπÂºèÔºö\n" 
							+ "[```]Ôºö‰∏â‰∏™ÂèçÂºïÂè∑ÔºàÈªòËÆ§Ôºâ\n" 
							+ "[~~~]Ôºö‰∏â‰∏™Ê≥¢Êµ™Âè∑", DEFAULT_CONFIG.NOTE.ESCAPE_STYLE.CODE);
			},
			'iw': () => {
				return confirm("ÊòØÂê¶‰ΩøÁî® Wiki ÈìæÊé•Ôºü\n" 
								+ "Á°ÆËÆ§ÔºöÊòØÔºà‰ΩøÁî® [[Êñá‰ª∂Âêç]]„ÄÅ![[ÂõæÁâáÂêç]] ÂΩ¢ÂºèÔºâ\n" 
								+ "ÂèñÊ∂àÔºöÂê¶Ôºà‰ΩøÁî®Ê†áÂáÜÁöÑ Markdown ËØ≠Ê≥ïÔºâ");
			},
			'is': () => {
				return confirm("„ÄêÊ≥®ÊÑèÔºöÂÖ±" + videoInfo.count + "‰∏™ËßÜÈ¢ë„ÄëÊòØÂê¶ÂàÜÊàêÂ§ö‰∏™Á¨îËÆ∞Êñá‰ª∂Ôºü\n" 
								+ "Á°ÆËÆ§ÔºöÊòØÔºà‰∏Ä‰∏™Ê∏ÖÂçïÊñá‰ª∂ + n‰∏™Á¨îËÆ∞Êñá‰ª∂Ôºâ\n" 
								+ "ÂèñÊ∂àÔºöÂê¶ÔºàÊ∏ÖÂçï + Á¨îËÆ∞Â∞ÜÊï¥Âêà‰∏∫‰∏Ä‰∏™Êñá‰ª∂Ôºâ");
			},
			'ic': () => {
				return confirm("ÊòØÂê¶ÈúÄË¶ÅÊâìÂåÖÂéãÁº©Ôºü\n" 
								+ "Á°ÆËÆ§ÔºöÊòØ\n" 
								+ "ÂèñÊ∂àÔºöÂê¶");
			}
		};

		let combinator = {
			'catalog': () => {
				return {
					style: selector['cs'](),
					lineBreak: selector['cbr']()
				};
			},
			'title': () => {
				return {
					pattern: selector['tp'](),
					level: selector['tl']()
				};
			},
			'note': () => {
				return {
					escapeStyle: {
						lineBreak: selector['nbr'](),
						bold: selector['b'](),
						italic: selector['i'](),
						list: selector['li'](),
						code: selector['code']()
					}
				};
			}
		}

		let page_combinator = {
			'single_page': () => {
				if (!isOpenNote) return {};

				if (selector['ikd']()) return {};

				return { note: combinator['note'](), isWiki: selector['iw']() };
			},
			'multi_page': () => {
				if (selector['ikd']()) return { isSeparate: selector['is']() };

				let obj = { catalog: combinator['catalog'](), title: combinator['title']() };
				if (isOpenNote) obj = { ...obj, ...{ note: combinator['note']() } };
				obj = { ...obj, ...{ isWiki: selector['iw']() } };
				return { ...obj, ...{ isSeparate: selector['is']() } };
			}
		}

		let option = null;

		if (videoInfo.type == 1) {
			option = page_combinator['single_page']();
		}

		if (videoInfo.type == 2) {
			option = page_combinator['multi_page']();
		}

		if (videoInfo.type == 3) {
			let ioc = selector['ioc']();

			if (ioc) {
				option = { ...{ isOnlyCurr: true }, ...page_combinator['single_page']() };
			} else {
				option = { ...{ isOnlyCurr: false }, ...page_combinator['multi_page']() };
			}
		}

		if (option) option = { ...option, ...{ isCompression: selector['ic']() } };

		return option;
	}

	function optionToSetting(option) {
		let setting = {};

		let str = JSON.stringify(DEFAULT_CONFIG);
		str = str.replace(/[{,]"[A-Z]+(_[A-Z]+)*"/g, function($0, $1) {
			return $0.toLowerCase().replace(/(?<=[a-z])_([a-z])/g, function($0, $1) {
				return $1.toUpperCase();
			});
		});
		let defaultConfig = JSON.parse(str);

		for (let k in defaultConfig) setting[k] = defaultConfig[k];

		if (option && typeof option == 'object') {
			let ioc = option.isOnlyCurr;
			if (typeof ioc == 'boolean') setting.isOnlyCurr = ioc;

			let catalog = option.catalog;
			if (catalog && typeof catalog == 'object') {
				for (let k in catalog) {
					if (typeof catalog[k] == 'string') setting.catalog[k] = catalog[k];
				}
			}

			let title = option.title;
			if (title && typeof title == 'object') {
				for (let k in title) {
					if (typeof title[k] == 'string') setting.title[k] = title[k];
				}
			}

			let note = option.note;
			if (note && typeof note == 'object') {
				let nel = note.escapeLevel;
				if (typeof nel == 'string') setting.note.escapeLevel = nel;

				let nes = note.escapeStyle;
				if (nes && typeof nes == 'object') {
					for (let k in nes) {
						if (typeof nes[k] == 'string') setting.note.escapeStyle[k] = nes[k];
					}
				}
			}

			let iw = option.isWiki;
			if (typeof iw == 'boolean') setting.isWiki = iw;

			let is = option.isSeparate;
			if (typeof is == 'boolean') setting.isSeparate = is;

			let ic = option.isCompression;
			if (typeof ic == 'boolean') setting.isCompression = ic;
		}

		setting.fileName = 'Á¨îËÆ∞Ê∏ÖÂçï' + new Date().getTime();
		let f = videoInfo.type == 3 ? videoInfo.season.title : videoInfo.title;
		setting.folder = f ? f.replace(/[\\\/\:\*\?\"\<\>\|]/g, '') : 'Á¨îËÆ∞';
		setting.attachment = 'ÈôÑ‰ª∂';

		return setting;
	}

	class Video {
		constructor(data, exNote) {
			this.data = data;
			this.exNote = exNote;
			this.catalog = '';
			this.note = '';
			this.files = [];
		}

		process() {
			console.log('subclass implement');
		}

		outLink(title) {
			let copy = title;
			let pattern = setting.isWiki ? '[[{link}|{display}]]' : '[{display}]({link})';
			let linkFix = setting.isSeparate ? '' : setting.fileName + '#';
			let link = '', display = '';

			let ascll = /[\~\`\!\@\#\$\%\^\&\*\(\)\-\_\+\=\{\[\}\]\|\\\:\;\"\'\<\,\>\.\?\/ ]/g;
			let encode = ($0) => { return !['(', ')'].includes($0) ? encodeURI($0) : ($0 == '(' ? '%28' : '%29'); }
			
			let wikiLinkReg = { r: /[\#\^\|\\]/g, $: ' ' };
			let wikiDisplayReg = { r: /(\[\])/g, $: ' $1' };
			let mdLinkReg = { r: ascll, $: encode };
			let mdDisplayReg = { r: /(\[\])/g, $: '\\$1' };

			if (setting.isSeparate) {
				let fileNameReg = { r: /[\#\^\[\]\|\*\"\\\/\<\>\:\?\~]/g, $: ' ' };
				title = title.replace(fileNameReg.r, fileNameReg.$);
				title = title.replace(/ +$/g, '');
				
				if (setting.isWiki) {
					link = linkFix + title.replace(wikiLinkReg.r, wikiLinkReg.$);
					display = copy.replace(wikiDisplayReg.r, wikiDisplayReg.$);
				} else {
					link = linkFix + title.replace(mdLinkReg.r, mdLinkReg.$);
					display = copy.replace(mdDisplayReg.r, mdDisplayReg.$);
				}
			} else {
				let titleReg = { r: /([\`\#\^\*\[\]\\\<\>])/g, $: '\\$1' };
				title = title.replace(titleReg.r, titleReg.$);

				if (setting.isWiki) {
					link = linkFix + title.replace(wikiLinkReg.r, wikiLinkReg.$);
					display = copy.replace(wikiDisplayReg.r, wikiDisplayReg.$);
				} else {
					link = linkFix + title.replace(mdLinkReg.r, mdLinkReg.$);
					display = title;
				}

				title = setting.title.level + ' ' + title;
			}

			let line = pattern.replace(/{link}/g, link).replace(/{display}/g, display);
			return { title: title, line: line };
		}

		separate(titles, notes) {
			if (setting.isSeparate) {
				titles.forEach((o, i) => {
					let content = o.hasOwnProperty('pic') ? 
									AssembleFactory("intro").format(o.pic, o.title, o.href) : 
									AssembleFactory("introNoImg").format(o.title, o.href);

					let index = notes.findIndex(function(t) { return t.index == i; });
					content += AssembleFactory("note").format(index > -1 ? notes[index].content : '');

					this.files.push({ fileName: o.content, content: content });
				});
			} else {
				let content = '';

				titles.forEach(function(o, i) {
					content += o.content + '\n\n';

					let index = notes.findIndex(function(t) {return t.index == i; });
					if (index > -1) content += notes[index].content + '\n';
				});

				this.files.push({ fileName: setting.fileName, content: content });
			}
		}

		assemble(pic, title, url) {
			console.log('subclass implement');
		}

		download() {
			let o = {
				compression: setting.isCompression,
				folder: setting.folder,
				attachment: setting.attachment
			};
			createAndDownloadFile(this.files, this.exNote.images(), o);
		}

		run() {
			this.process();
			this.download();
		}
	}

	class SingleVideo extends Video {
		constructor(data, exNote) {
			super(data, exNote);
		}

		process() {
			this.note = this.exNote.get();
			this.assemble(videoInfo.pic, videoInfo.title, videoInfo.url);
		}

		assemble(pic, title, url) {
			let intro = AssembleFactory("intro").format(pic, title, url);
			let note = AssembleFactory("note").format(this.note);
			let content = intro + note;

			this.files.push({ fileName: setting.fileName, content: content });
		}
	}

	class EpisodeVideo extends Video {
		constructor(data, exNote) {
			super(data, exNote);
		}

		process() {
			let parts = this.data.map(function(o) { return o.part; });
			let arr = parts.map(function(o) {
				return o.replace(/([\$\(\)\*\+\.\[\]\?\\\^\{\}\|])/g, '\\$1');
			});
			let reg = new RegExp(`(?<=[^\\\\])\\[(${arr.join("|")})`, "g");
			let slices = this.exNote.slice(reg);

			let catalog = new Catalog(setting.catalog.style, 'ËßÜÈ¢ëÈÄâÈõÜ');
			let titles = [], notes = [];
			this.data.forEach((o, i) => {
				let title = setting.title.pattern
								.replace(/{x}/g, o.page)
								.replace(/{xxx}/g, o.part);

				let href = videoInfo.url + '?p=' + o.page;

				let obj = this.outLink(title);
				
				catalog.push(obj.line + `[ ](${href})`);

				titles.push({ content: obj.title, title: o.part, href: href });

				if (slices.length > 0) {
					let temps = slices.filter(function(t) {
						let part = o.part.replace(/([\$\(\)\*\+\.\[\]\?\\\^\{\}\|])/g, '\\$1');
						return new RegExp(`\\[${part} P${o.page}`, "g").test(t);
					});
					if (temps.length > 0) notes.push({ content: temps.join(''), index: i });
				}
			});
			this.catalog = catalog.get();

			if (slices.length > 0 && !reg.test(slices[0])) this.note = slices[0] + "\n\n";

			this.separate(titles, notes);
			if (this.files.length == 1) this.note += this.files.pop().content + '\n';

			this.assemble(videoInfo.pic, videoInfo.title, videoInfo.url);
		}

		assemble(pic, title, url) {
			let tips = AssembleFactory("tips").format();
			let intro = AssembleFactory("intro").format(pic, title, url);
			let catalog = AssembleFactory("catalog").format(this.catalog);
			let note = AssembleFactory("note").format(this.note);
			let content = tips + intro + catalog + note;

			this.files.push({ fileName: setting.fileName, content: content });
		}
	}

	class SeasonVideo extends Video {
		constructor(data, exNote) {
			super(data, exNote);
		}

		process() {
			let exNote = this.exNote.get();

			if (setting.isOnlyCurr) {
				for (let i = 0; i < this.data.length; i++) {
					for (let ii = 0; ii < this.data[i].episodes.length; ii++) {
						let episode = this.data[i].episodes[ii];
						if (episode.bvid == videoInfo.bvid) {
							let href = 'https://www.bilibili.com/video/' + episode.bvid;
							let arr = [episode.arc.pic, episode.title, href];

							let intro = AssembleFactory("intro").format(...arr);
							let note = AssembleFactory("note").format(exNote);
							let content = intro + note;

							this.files.push({ fileName: setting.fileName, content: content });
						}
					}
				}
				return;
			}

			let catalog = new Catalog(setting.catalog.style, 'ËßÜÈ¢ëÂêàÈõÜ');
			let titles = [], notes = [];
			let p = 1;
			this.data.forEach((o) => {
				o.episodes.forEach((oo) => {
					let title = setting.title.pattern
									.replace(/{x}/g, p++)
									.replace(/{xxx}/g, oo.title);

					let href = 'https://www.bilibili.com/video/' + oo.bvid;

					let obj = this.outLink(title);

					catalog.push(obj.line + `[ ](${href})`);

					titles.push({ content: obj.title, pic: oo.arc.pic, title: oo.title, href: href });

					if (exNote && videoInfo.bvid == oo.bvid) {
						notes.push({ content: exNote, index: p-2 });
					}
				});
			});
			this.catalog = catalog.get();

			this.separate(titles, notes);
			if (this.files.length == 1) this.note = this.files.pop().content + '\n';

			this.assemble(videoInfo.season.cover, videoInfo.season.title, videoInfo.collectionUrl);
		}

		assemble(pic, title, url) {
			let tips = AssembleFactory("tips").format();
			let intro = AssembleFactory("intro").format(pic, title, url);
			let catalog = AssembleFactory("catalog").format(this.catalog);
			let note = AssembleFactory("note").format(this.note);
			let content = tips + intro + catalog + note;

			this.files.push({ fileName: setting.fileName, content: content });
		}
	}

	function VideoFactory(type, exNote) {
		let selector = {
			1: () => { return new SingleVideo(null, exNote); },
			2: () => { return new EpisodeVideo(videoInfo.pages, exNote); },
			3: () => { return new SeasonVideo(videoInfo.season.sections, exNote); }
		}

		return selector[type]();
	}

	function AssembleFactory(part) {
		const ASSEMBLE_PATTERN = {
			TIPS: [
				'>[!warning] Ë≠¶ÂëäÔºÅÔºÅÔºÅ\n', 
				'>- Â¶ÇÊûúÊúâÂá∫ÈìæÔºåÂÖàÊü•ÁúãÂá∫ÈìæÈù¢Êùø‰∏ãÁöÑÊï∞ÊçÆÊòØÂê¶ËØÜÂà´ÊàêÂäü\n', 
				'>- ÊâìÂºÄ‚ÄúËÆæÁΩÆ‚Äù-‚ÄúÈÄâÈ°π‚Äù-‚ÄúÊñá‰ª∂‰∏éÈìæÊé•‚Äù-‚ÄúÂßãÁªàÊõ¥Êñ∞ÂÜÖÈÉ®ÈìæÊé•‚ÄùÂäüËÉΩ\n', 
				'>- Á°ÆËÆ§ÂêéÊñπÂèØÈáçÊñ∞‰øÆÊîπÁ¨îËÆ∞ÂêçÁß∞\n',
				'>- Ê≤°ÊúâÂá∫ÈìæÁöÑÂèØÁõ¥Êé•ÂøΩÁï•‰ª•‰∏äÊ≠•È™§\n',
				'>- Á°ÆËÆ§Á¨îËÆ∞Êó†ËØØÂêéÂèØÊ†πÊçÆÊÉÖÂÜµÂà†Èô§ËØ•Ë≠¶Âëä\n', 
				'\n'
			],
			INTRO: [
				'![]({x})\n', 
				'\n', 
				'# {x}[ ]({x})\n', 
				'> **xxxxxx**\n', 
				'\n'
			],
			CATALOG: [
				'# Ê∏ÖÂçï\n', 
				'\n', 
				'{x}', 
				'\n'
			],
			NOTE: [
				'# Á¨îËÆ∞\n', 
				'\n', 
				'{x}', 
				'\n'
			],
			INTRO_NO_IMG: [
				'# {x}[ ]({x})\n', 
				'> **xxxxxx**\n', 
				'\n'
			]
		};

		function Assemble(pattern) {
			this.pattern = pattern.join('');

			this.format = (...args) => {
				let i = 0;
				return this.pattern.replace(/{x}/g, function() {
					return args[i++];
				});
			}
		}
		
		let selector = {
			'tips': () => { return new Assemble(ASSEMBLE_PATTERN.TIPS); },
			'intro': () => { return new Assemble(ASSEMBLE_PATTERN.INTRO); },
			'catalog': () => { return new Assemble(ASSEMBLE_PATTERN.CATALOG); },
			'note': () => { return new Assemble(ASSEMBLE_PATTERN.NOTE); },
			'introNoImg': () => { return new Assemble(ASSEMBLE_PATTERN.INTRO_NO_IMG); }
		}

		return selector[part]();
	}

	function Catalog(style, title) {
		this.style = style;
		this.title = title;
		this.first = '';
		this.prefix = '';
		this.br = !['  ', '\n'].includes(setting.catalog.lineBreak) ?
								DEFAULT_CONFIG.CATALOG.LINE_BREAK : 
										setting.catalog.lineBreak;
		this.suffix = '\n';
		this.last = '';
		this.output = '';

		this.push = (input) => {
			this.output += this.prefix + input;
			this.output += this.br == DEFAULT_CONFIG.CATALOG.LINE_BREAK ? 
							this.br : 
							(['È£éÊ†º‰∏Ä','È£éÊ†º‰∫å','È£éÊ†º‰∏â'].includes(this.style) ? '\n> ' : '\n');
			this.output += this.suffix;
		}

		this.get = () => {
			return this.first + this.output + this.last;
		}


		let selector = {
			'È£éÊ†º‰∏Ä': (title) => {
				this.first = '>[!info] **' + (!title ? 'ËßÜÈ¢ëÂàÜÈõÜ' : title) + '**\n';
				this.prefix = '> - [ ] ';
				this.last = '\n';
			},
			'È£éÊ†º‰∫å': (title) => {
				this.first = '>[!info] **' + (!title ? 'ËßÜÈ¢ëÂàÜÈõÜ' : title) + '**\n';
				this.prefix = '> - ';
				this.last = '\n';
			},
			'È£éÊ†º‰∏â': (title) => {
				this.first = '>[!info] **' + (!title ? 'ËßÜÈ¢ëÂàÜÈõÜ' : title) + '**\n';
				this.prefix = '> ';
				this.last = '\n';
			},
			'È£éÊ†ºÂõõ': (title) => {
				this.first = '---\n';
				this.prefix = '- [ ] ';
				this.last = '---\n';
			},
			'È£éÊ†º‰∫î': (title) => {
				this.first = '---\n';
				this.prefix = '- ';
				this.last = '---\n';
			},
			'È£éÊ†ºÂÖ≠': (title) => {
				this.first = '---\n';
				this.prefix = '';
				this.last = '---\n';
			}
		}

		function init(style, title) {
			selector[style](title);
		}

		init(this.style, this.title);
	}

	function ExNote(editor) {
		const EDITOR_ELEMENT = {
			BLOCK: {
				P: 'P',
				OL: 'OL',
				UL: 'UL',
				LI: 'LI',
				DIV: 'DIV',
				PRE: 'PRE'
			},
			INLINE: {
				BR: 'BR',
				B: 'B',
				STRONG: 'STRONG',
				I: 'I',
				EM: 'EM',
				U: 'U',
				S: 'S',
				SPAN: 'SPAN'	
			}
		};

		this.editor = editor;
		this.res = '';
		this.imgs = [];
		this.slices = [];

		this.raw = () => {
			return this.editor;
		}

		this.get = () => {
			return this.res;
		}

		this.images = () => {
			return this.imgs;
		}

		this.slice = (reg) => {
			if (!reg || this.res.length == 0) return this.slices;

			let lastIndex = 0;
			while (lastIndex > -1) {
				let result = reg.exec(this.res);
				if (result != null) {
					this.slices.push(this.res.slice(lastIndex, result.index));
					lastIndex = result.index;
				} else {
					this.slices.push(this.res.slice(lastIndex < 0 ? 0 : lastIndex));
					lastIndex = -1;
				}
			}

			return this.slices;
		}


		let init = () => {
			//if (!this.editor || this.editor.classList.contains("ql-blank")) return;
			if (!this.editor) return;

			if (!isVaildNode(editor)) return;

			let obj = parse(this.editor);
			this.res = obj.lines;
			this.imgs = obj.imgs;
		}

		init();


		function parse(editor) {
			let nodes = editor.childNodes;
			if (!nodes || nodes.length <= 0) return '';

			var lines = [];
			var imgs = [];

			for (let i = 0; i < nodes.length; i++) {
				let node = nodes[i];
				if (!isVaildNode(node)) continue;

				switch (node.nodeName) {
					case EDITOR_ELEMENT.BLOCK.P: 
						pToLine(node, lines);
						break;
					case EDITOR_ELEMENT.BLOCK.OL: 
						olToLine(node, lines);
						break;
					case EDITOR_ELEMENT.BLOCK.UL: 
						ulToLine(node, lines);
						break;
					case EDITOR_ELEMENT.BLOCK.DIV: 
						divToLine(node, lines, imgs);
						break;
					case EDITOR_ELEMENT.BLOCK.PRE: 
						preToLine(node, lines);
						break;
					default: 
						lines.push(node.textContent);
				}
			}

			return { lines: lines.join(setting.note.escapeStyle.lineBreak + "\n"), imgs: imgs };
		}

		function pToLine(node, lines) {
			lines.push(convert(node));
		}

		function olToLine(node, lines) {
			liToLine(node, lines, EDITOR_ELEMENT.BLOCK.OL);
		}

		function ulToLine(node, lines) {
			liToLine(node, lines, EDITOR_ELEMENT.BLOCK.UL);
		}

		function liToLine(node, lines, parent) {
			let nodes = node.childNodes;
			if (!nodes || nodes.length <= 0) return;

			let currLevel = 0;
			let levelIndex = {};
			
			for (let i = 0; i < nodes.length; i++) {
				let node = nodes[i];
				if (!isVaildNode(node)) continue;

				let className = node.getAttribute("class");
				if (!className) {
					currLevel = 0;
				} else {
					currLevel = className
								.match(/\bql-indent-[1-9]+\b/)[0]
								.match(/[1-9]+/)[0];
				}
				levelIndex[currLevel] || levelIndex[currLevel] == 0 ? 
				levelIndex[currLevel] += 1 : 
				levelIndex[currLevel] = 0;

				let character = "\t".repeat(currLevel);
				character += parent == EDITOR_ELEMENT.BLOCK.OL ? 
							(levelIndex[currLevel] + 1) + ". " : 
							setting.note.escapeStyle.list + " ";
				lines.push(character + convert(node));
			}
		}

		function divToLine(node, lines, imgs) {
			if (node.classList && node.classList.contains("ql-image-preview")) {
				let path = "path_" + imgs.length;
				let line = !setting.isWiki ? "![]({" + path + "})" : "![[{" + path + "}]]";
				lines.push(line);

				imgs.push(getImage(node));
			}
		}

		function preToLine(node, lines) {
			if (node.classList && node.classList.contains("ql-syntax")) {
				lines.push(format(node, setting.note.escapeStyle.code));
			} else {
				lines.push(node.textContent);
			}
		}

		function convert(node, isHead) {
			let nodes = node.childNodes;
			if (!nodes || nodes.length <= 0) return "";

			let block = "";
			
			for (var i = 0; i < nodes.length; i++) {
				let node = nodes[i];

				if (node.classList && node.classList.contains("ql-tag-blot")) {
					block += "[" + getTitle(node) + "](" + getUrl(node) + ")";
				} else {
					isHead = typeof isHead == 'boolean' ? isHead && i == 0 : i == 0;
					switch (node.nodeName) {
						case EDITOR_ELEMENT.INLINE.BR: 
							block += "";
							break;
						case EDITOR_ELEMENT.INLINE.B: 
						case EDITOR_ELEMENT.INLINE.STRONG: 
							block += format(node, 
											setting.note.escapeStyle.bold, 
											isHead);
							break;
						case EDITOR_ELEMENT.INLINE.I: 
						case EDITOR_ELEMENT.INLINE.EM: 
							block += format(node, 
											setting.note.escapeStyle.italic, 
											isHead);
							break;
						case EDITOR_ELEMENT.INLINE.U: 
							block += format(node, 
											setting.note.escapeStyle.underlined, 
											isHead);
							break;
						case EDITOR_ELEMENT.INLINE.S: 
							block += format(node, 
											setting.note.escapeStyle.strikethrough, 
											isHead);
							break;
						case EDITOR_ELEMENT.INLINE.SPAN: 
							block += format(node, 
											"", 
											isHead);
							break;
						default:
							block += format(node, 
											"", 
											isHead);
					}
				}
			}

			return block;
		}

		function format(node, character, isHead) {
			let content = "";
			if (isEnd(node)) {
				content = node.textContent;
				content = escape(content, isHead);
			} else {
				content = convert(node, isHead);
			}
			
			let s = typeof character == 'object' ? character.start : character;
			let e = typeof character == 'object' ? character.end : character;
			let bs = /^ +/.test(content) ? content.match(/^ +/)[0] : "";
			let ae = / +$/.test(content) ? content.match(/ +$/)[0] : "";
			let text = content.replace(/^ +/, "").replace(/ +$/, "");
			return bs + s + text + e + ae;
		}

		function escape(content, isHead) {
			if (typeof isHead != 'boolean') return content;

			for (let k in CONFIG.NOTE.ESCAPE_RULE) {
				let rule = CONFIG.NOTE.ESCAPE_RULE[k];
				
				if (!isHead && rule.IS_HEAD) continue;
				
				if (!rule.IS_LOOP) {
					content = content.replace(rule.REGEXP, rule.REPLACEMENT);
				} else {
					while (rule.REGEXP.test(content)) {
						content = content.replace(rule.REGEXP, rule.REPLACEMENT);
					}
				}
			}

			return content;
		}

		function getImage(node) {
			let img = node.querySelector("img");
			let src = img ? "https:" + img.getAttribute("src") : "";
			return src ? (src.includes("http") ? src : "https:" + src) : "";
		}

		function getTime(node) {
			let seconds = node.getAttribute("data-seconds");
			let h = parseInt(seconds / 60 /60 % 24);
			h = h < 10 ? '0' + h : h;
			let m = parseInt(seconds / 60 % 60);
			m = m < 10 ? '0' + m : m;
			let s = parseInt(seconds % 60);
			s = s < 10 ? '0' + s : s;
			return h == '00' ? m + ':' + s : h + ':' + m + ':' + s;
		}

		function getTitle(node) {
			let text = node.querySelector(".time-tag-item__text");
			let desc = node.querySelector(".time-tag-item__desc");
			return text.firstChild.textContent + (desc ? ' ' + desc.textContent : '');
		}

		function getUrl(node) {
			let index = node.getAttribute("data-index");
			let seconds = node.getAttribute("data-seconds");
			let url = videoInfo.url;
			return (index > 0 ? url + '?p=' + index : url) + '#t=' + seconds;
		}

		function isVaildNode(node) {
			return node.nodeType == NODE_TYPE.ELEMENT;
		}

		function isEnd(node) {
			return !node.children || node.children.length == 0;
		}
	}

	function Request(url, params) {
		this.url = url;
		this.params = params;
		this.xhr = Xhr();
		this.res;

		this.get = () => {
			open('get', this.url + parseParams());
			send(null);
			return this.res;
		}

		this.post = () => {
			return this.res;
		}

		this.close = () => {
			Xhr = null;
		}


		let parseParams = () => {
			if (!this.params) return '';

			if (typeof this.params != 'object') throw 'params is not object';

			let arr = [];
			for (let k in this.params) {
				let key = encodeURIComponent(k);
				let value = encodeURIComponent(this.params[k]);
				arr.push(key + '=' + value);
			}

			return '?' + arr.join('&');
		}

		let open = (method, url) => {
			this.xhr.open(method, url, false);
		}

		let send = (body) => {
			this.xhr.send(body);
			this.res = this.xhr.responseText;
		}
	}

	var Xhr = (function() {
		let instance = null;

		return function() {
			if (!instance) {
				let XHR = [
					function() { return new XMLHttpRequest() },
					function() { return new ActiveXObject("Msxml2.XMLHTTP") },
					function() { return new ActiveXObject("Msxml3.XMLHTTP") },
					function() { return new ActiveXObject("Microsoft.XMLHTTP") }
				];

				for (let i = 0; i < XHR.length; i++) {
					try {
						instance = XHR[i]();
					} catch(e) {
						continue;
					}
					break;
				}
			}

			return instance;
		}
	})();
	
	function createAndDownloadFile(notes, images, option) {
		if (!notes || !images) return;

		if (option && option.compression) {
			setTimeout(function() {
				compression(notes, images, option.folder, option.attachment);
			}, 500);
		} else {
			loopDownload(notes, images);
		}

		async function loopDownload(notes, images) {
			let sum = notes.length + images.length;
			let delay = Math.ceil(sum / 50) * 100;
			let count = 0;

			if (images && images.length > 0) {
				for (let i = 0; i < images.length; i++) {
					await getImage(images[i]).then(function(obj) {
						let fullname = obj.fileName + '.' + obj.suffix;
						
						let reg = new RegExp("{path_" + i + "}", "g");
						notes.forEach(function(o) {
							o.content = o.content.replace(reg, fullname);
						});

						setTimeout(function() {
							downloadFile(fullname, obj.content);
						}, count * delay);
						count++;
					}).catch(function(e) {
						console.error(e);
					});
				}
			}

			notes.forEach(function(o) {
				setTimeout(function() {
					downloadFile(o.fileName + '.md', o.content);
				}, count * delay);
				count++;
			});
		}

		async function compression(notes, images, folder, attachment) {
			try {
				let zip = new JSZip();

				let f = zip.folder(folder);

				if (images && images.length > 0) {
					let a = f.folder(attachment);

					for (let i = 0; i < images.length; i++) {
						await getImage(images[i]).then(function(obj) {
							let fullname = obj.fileName + '.' + obj.suffix;
							let path = attachment + '/' + fullname;
							
							let reg = new RegExp("{path_" + i + "}", "g");
							notes.forEach(function(o) {
								o.content = o.content.replace(reg, path);
							});

							a.file(fullname, obj.content);
						}).catch(function(e) {
							console.error(e);
						});
					}
				}

				notes.forEach(function(o) {
					f.file(o.fileName + '.md', o.content);
				});
				
				zip.generateAsync({ type: 'blob' }).then(function(content) {
					downloadFile('BÁ´ôÁ¨îËÆ∞' + new Date().getTime() + '.zip', content);
				});

				zip = null;
				let script = document.getElementById("jszip");
				if (script) document.head.removeChild(script);
			} catch(e) {
				console.error(e);
				alert("ÂéãÁº©Êñá‰ª∂Â§±Ë¥•ÔºåËØ∑ÈáçËØïÊàñËÄÖÈÄâÊã©‰∏çÂéãÁº©");
			}
		}

		function getImage(src) {
			if (!src) return null;

			let credentials = src.includes('bilibili.com') ? 'include' : 'omit';

			return fetch(src, {
				method: 'get',
				credentials: credentials
			}).then(function(res) {
				if (res.status == 200) {
					let contentType = res.headers.get('Content-Type');
					
					if (contentType.includes('image/')) {
						return res.blob();
					}
				}
			}).then(function(blob) {
				let f = src.includes('?') ? 
						src.substring(src.lastIndexOf('=') + 1) : 
						src.substring(src.lastIndexOf('/') + 1, src.lastIndexOf('.'));
				let s = blob.type.substring(blob.type.indexOf('/') + 1);
				return { fileName: f, suffix: s, content: blob };
			});
		}

		function downloadFile(fileName, content) {
			let blob = new Blob([content]);
			let aTag = document.createElement('a');
			aTag.download = fileName;
			aTag.href = URL.createObjectURL(blob);
			aTag.click();
			URL.revokeObjectURL(blob);
		}
	}


	function BiliService(option, bv) {
		this.option = option;
		this.bv = bv;

		this.toNote = () => {
			isOpenBiliBili();

			let iov = isOpenVideo();

			let ion = isOpenNote(iov.isOpenVideo, iov.bvid, this.bv);

			videoInfo = getVideoInfo(iov.isOpenVideo, iov.bvid, this.bv);
			
			if (!this.option) this.option = getOption(ion.isOpenNote);

			setting = optionToSetting(this.option);

			VideoFactory(videoInfo.type, new ExNote(ion.editor)).run();
		}

		function init(option, bv) {
			if (option && typeof option != 'object') throw 'param option is not object';
			if (bv && typeof bv != 'string') throw 'param bv is not string';

			if (window.location.href.includes('bilibili.com')) {
				var script = document.createElement("script");
				script.id = "jszip";
				script.type = "text/javascript";
				script.src = "https://cdn.jsdelivr.net/gh/Stuk/jszip@main/dist/jszip.min.js";
				document.head.appendChild(script);
			}
		}

		init(this.option, this.bv);
	}

	return BiliService;
})();

/*
================================= Êó†ÁâπÊÆäÈúÄÊ±Ç‰∏çÁî®ÂÖ≥Ê≥®Ê≠§ÈÉ®ÂàÜËØ¥Êòé =====================================

‰∏Ä„ÄÅ‰ΩøÁî®ËØ¥Êòé

	1. ‰øÆÊîπ option ‰∏≠ÁöÑÂêÑ‰∏™ null ‰∏∫ÂÖ∑‰ΩìÂÄºÔºåÂèØÂÆûÁé∞‰∏ÄÊ¨°ÈÖçÁΩÆÂ§öÊ¨°‰ΩøÁî®Ôºà‰øùÂ≠òÂ•ΩÈÖçÁΩÆ‰ø°ÊÅØ‰∏ãÊ¨°Ë¶ÜÁõñÂç≥ÂèØÔºâ

	2. ‰øÆÊîπ BV Âè≥ËæπÁöÑ null ‰∏∫Êüê‰∏™ËßÜÈ¢ëBVÂè∑ÔºåÂèØÂÆûÁé∞‰∏ãËΩΩÊåáÂÆöËßÜÈ¢ëÊ∏ÖÂçïÔºà‰ªÖ‰∏ãËΩΩÊ∏ÖÂçïÂíåÂàÜÈõÜ‰ø°ÊÅØÔºå‰∏™‰∫∫Á¨îËÆ∞Êó†Ê≥ïÊìç‰ΩúÔºâ

	3. ‰øÆÊîπ Ji_iL(null, null) ‰∏≠ÁöÑ‰∏§‰∏™ null ÂàÜÂà´‰∏∫ option Âíå BVÔºåÂè™‰øÆÊîπÂÖ∂‰∏≠‰∏Ä‰∏™ÔºåÂè¶‰∏Ä‰∏™‰øùÊåÅ null

	4. Âú®ÊéßÂà∂Âè∞ÂÜÖÂõûËΩ¶ÊâßË°å

‰∫å„ÄÅ‰øÆÊîπÁ§∫‰æã

	1. Ê†πÊçÆ ‰∏â„ÄÅÂèÇÊï∞ËØ¥Êòé ‰∏≠ÁöÑÂêÑÈ°πÂèÇÊï∞ÈÄâÊã©ÊÉ≥Ë¶ÅÊõøÊç¢ÁöÑÁ¨¶Âè∑Âπ∂‰øÆÊîπ‰∏ãÂàó option ‰∏≠ÁöÑÂÄºÔºå‰∏ç‰øÆÊîπÁöÑ‰øùÊåÅ null
		var option = {
			isOnlyCurr: true,
			catalog: {
				style: "È£éÊ†º‰∫î",
				lineBreak: "\n"
			},
			title: {
				pattern: "Á¨¨ {x} ÈõÜÔºö„Ää{xxx}„Äã",
				level: "######"
			},
			note: {
				escapeStyle: {
					lineBreak: null,
					bold: "**",
					italic: null,
					list: null,
					code: "~~~"
				}
			},
			isWiki: true,
			isSeparate: true,
			isCompression: true
		};

	2. Ê†πÊçÆ‰∏™‰∫∫ÈúÄË¶ÅÔºåÂ°´ÂÖ•ËßÜÈ¢ëBVÂè∑
		var BV = "BV......7w6";

	3. Êã¨Âè∑‰∏≠Â°´ÂÖ• option Âíå BV
		a. Ji_iL(null, null);     ÈªòËÆ§ÈÖçÁΩÆ + ÂΩìÂâçËßÜÈ¢ë
		b. Ji_iL(option, null);   Ëá™ÂÆö‰πâÈÖçÁΩÆ + ÂΩìÂâçËßÜÈ¢ë
		c. Ji_iL(null, BV);       ÈªòËÆ§ÈÖçÁΩÆ + ÊåáÂÆöËßÜÈ¢ë
		d. Ji_iL(option, BV);     Ëá™ÂÆö‰πâÈÖçÁΩÆ + ÊåáÂÆöËßÜÈ¢ë


‰∏â„ÄÅÂèÇÊï∞ËØ¥Êòé

	1. option ÔºöËá™ÂÆö‰πâÈÖçÁΩÆ

	-- isOnlyCurr    : ÊòØÂê¶Âè™‰∏ãËΩΩÂΩìÂâç‰∏ÄÈõÜÔºåÂêàÈõÜËßÜÈ¢ëÊúâÊïàÔºåÈÄâÊã©‰∏ãÂàó‰∏§‰∏™ÈÄâÈ°π‰∏≠ÁöÑÂÖ∂‰∏≠‰∏Ä‰∏™
						true  ÔºöÊòØÔºàÂè™‰∏ãËΩΩÂΩìÂâçËßÜÈ¢ëÊàñÊåáÂÆöËßÜÈ¢ëÔºâ
						false ÔºöÂê¶Ôºà‰∏ãËΩΩÂΩìÂâçËßÜÈ¢ëÊàñÊåáÂÆöËßÜÈ¢ëÊâÄÂú®ÂêàÈõÜÁöÑÂÖ®ÈÉ®ËßÜÈ¢ëÔºâ

	-- catalog ÔºöÊ∏ÖÂçïÁõ∏ÂÖ≥

	---- style       : ÂèØ‰ª•Êõ¥Êç¢ÂàÜÈõÜÊ∏ÖÂçïÁöÑÈ£éÊ†ºÔºåÈÄâÊã©‰∏ãÂàóÂÖ≠‰∏™ÈÄâÈ°π‰∏≠ÁöÑÂÖ∂‰∏≠‰∏Ä‰∏™
						"È£éÊ†º‰∏Ä" ÔºöÂºïÁî®ÂùóÂåÖË£π + todoÂàóË°®
						"È£éÊ†º‰∫å" ÔºöÂºïÁî®ÂùóÂåÖË£π + Êó†Â∫èÂàóË°®
						"È£éÊ†º‰∏â" ÔºöÂºïÁî®ÂùóÂåÖË£π
						"È£éÊ†ºÂõõ" Ôºö‰∏ä‰∏ãÂàÜÂâ≤Á∫øÂåÖË£π + todoÂàóË°®
						"È£éÊ†º‰∫î" Ôºö‰∏ä‰∏ãÂàÜÂâ≤Á∫øÂåÖË£π + Êó†Â∫èÂàóË°®
						"È£éÊ†ºÂÖ≠" Ôºö‰∏ä‰∏ãÂàÜÂâ≤Á∫øÂåÖË£π

	---- lineBreak   : Ê∏ÖÂçï‰∏≠ÁöÑÊç¢Ë°åÊñπÂºèÔºåÈÄâÊã©‰∏ãÂàó‰∏§‰∏™ÈÄâÈ°π‰∏≠ÁöÑÂÖ∂‰∏≠‰∏Ä‰∏™
						"\n" Ôºö‰ΩøÁî®Á©∫ÁôΩ‰∏ÄË°å‰ª£Ë°®Êç¢Ë°å
						"  " Ôºö‰ΩøÁî®‰∏§‰∏™Á©∫Ê†º‰ª£Ë°®Êç¢Ë°å

	-- title ÔºöÁ¨îËÆ∞Ê†áÈ¢òÁõ∏ÂÖ≥

	---- pattern     : ÂèØ‰ª•Ëá™ÂÆö‰πâÂàÜÈõÜÊ†áÈ¢òÁöÑÂ±ïÁ§∫Ê†ºÂºèÔºå‰æãÂ¶ÇÔºö
						"Á¨¨ {x} ÈõÜÔºö„Ää{xxx}„Äã" ===> Á¨¨ 1 ÈõÜÔºö„ÄäÂìàÂìàÂìà„Äã
													Á¨¨ 2 ÈõÜÔºö„ÄäÂëµÂëµÂëµ„Äã
													......
													Á¨¨ n ÈõÜÔºö„ÄäÂòªÂòªÂòª„Äã
						{x}   : ÈõÜÊï∞ÔºåËä±Êã¨Âè∑ÂåÖÁùÄ‰∏Ä‰∏™xÔºåË¶ÅÊ±ÇÊåâÊ≠§Ê†ºÂºè‰∏•Ê†º‰π¶ÂÜô
						{xxx} : ÂàÜÈõÜÊ†áÈ¢òÔºåËä±Êã¨Âè∑ÂåÖÁùÄ‰∏â‰∏™xÔºåË¶ÅÊ±ÇÊåâÊ≠§Ê†ºÂºè‰∏•Ê†º‰π¶ÂÜô

	---- lineBreak   : ‰∏™‰∫∫Á¨îËÆ∞ÂÜÖÂÆπÁöÑÊç¢Ë°åÊñπÂºèÔºåÈÄâÊã©‰∏ãÂàó‰∏§‰∏™ÈÄâÈ°π‰∏≠ÁöÑÂÖ∂‰∏≠‰∏Ä‰∏™
						"\n" Ôºö‰ΩøÁî®Á©∫ÁôΩ‰∏ÄË°å‰ª£Ë°®Êç¢Ë°å
						"  " Ôºö‰ΩøÁî®‰∏§‰∏™Á©∫Ê†º‰ª£Ë°®Êç¢Ë°å

	-- note ÔºöÁ¨îËÆ∞ÂÜÖÂÆπÁõ∏ÂÖ≥

	---- bold        : ‰∏™‰∫∫Á¨îËÆ∞ÂÜÖÂÆπÁöÑÂä†Á≤óÊñπÂºèÔºåÈÄâÊã©‰∏ãÂàó‰∏§‰∏™ÈÄâÈ°π‰∏≠ÁöÑÂÖ∂‰∏≠‰∏Ä‰∏™
						"**" Ôºö‰ΩøÁî®ÊòüÂè∑‰ª£Ë°®Âä†Á≤ó
						"__" Ôºö‰ΩøÁî®‰∏ãÂàíÁ∫ø‰ª£Ë°®Âä†Á≤ó

	---- italic      : ‰∏™‰∫∫Á¨îËÆ∞ÂÜÖÂÆπÁöÑÊñú‰ΩìÊñπÂºèÔºåÈÄâÊã©‰∏ãÂàó‰∏§‰∏™ÈÄâÈ°π‰∏≠ÁöÑÂÖ∂‰∏≠‰∏Ä‰∏™
						"*" Ôºö‰ΩøÁî®ÊòüÂè∑‰ª£Ë°®Êñú‰Ωì
						"_" Ôºö‰ΩøÁî®‰∏ãÂàíÁ∫ø‰ª£Ë°®Êñú‰Ωì

	---- list        : ‰∏™‰∫∫Á¨îËÆ∞ÂÜÖÂÆπÁöÑÊó†Â∫èÂàóË°®ÊñπÂºèÔºåÈÄâÊã©‰∏ãÂàó‰∏â‰∏™ÈÄâÈ°π‰∏≠ÁöÑÂÖ∂‰∏≠‰∏Ä‰∏™
						"-" Ôºö‰ΩøÁî®ÂáèÂè∑ÔºàËøûÂ≠óÁ¨¶Ôºâ‰ª£Ë°®Â∞èÂúÜÁÇπ
						"+" Ôºö‰ΩøÁî®Âä†Âè∑‰ª£Ë°®Â∞èÂúÜÁÇπ
						"*" Ôºö‰ΩøÁî®ÊòüÂè∑‰ª£Ë°®Â∞èÂúÜÁÇπ

	---- code        : ‰∏™‰∫∫Á¨îËÆ∞ÂÜÖÂÆπÁöÑ‰ª£Á†ÅÂùóÊñπÂºèÔºåÈÄâÊã©‰∏ãÂàó‰∏§‰∏™ÈÄâÈ°π‰∏≠ÁöÑÂÖ∂‰∏≠‰∏Ä‰∏™
						"```" Ôºö‰ΩøÁî®‰∏â‰∏™ÂèçÂºïÂè∑‰ª£Ë°®‰ª£Á†ÅÂùó
						"~~~" Ôºö‰ΩøÁî®‰∏â‰∏™Ê≥¢Êµ™Âè∑‰ª£Ë°®‰ª£Á†ÅÂùó

	-- isWiki        : ÊòØÂê¶ÊòØÂê¶‰ΩøÁî® Wiki ÈìæÊé•ÔºåÈÄâÊã©‰∏ãÂàó‰∏§‰∏™ÈÄâÈ°π‰∏≠ÁöÑÂÖ∂‰∏≠‰∏Ä‰∏™
						true  ÔºöÊòØÔºà‰ΩøÁî® [[Êñá‰ª∂Âêç]]„ÄÅ![[ÂõæÁâáÂêç]] ÂΩ¢ÂºèÔºâ
						false ÔºöÂê¶Ôºà‰ΩøÁî®Ê†áÂáÜÁöÑ Markdown ËØ≠Ê≥ïÔºâ

	-- isSeparate    : ÊòØÂê¶ÂàÜÂºÄ‰∏∫Â§ö‰∏™Á¨îËÆ∞Êñá‰ª∂ÔºåÂ§öÈõÜËßÜÈ¢ëÊúâÊïàÔºåÈÄâÊã©‰∏ãÂàó‰∏§‰∏™ÈÄâÈ°π‰∏≠ÁöÑÂÖ∂‰∏≠‰∏Ä‰∏™
						true  ÔºöÊòØÔºà‰∏Ä‰∏™Ê∏ÖÂçïÊñá‰ª∂ + n‰∏™Á¨îËÆ∞Êñá‰ª∂Ôºâ
						false ÔºöÂê¶ÔºàÊ∏ÖÂçï + Á¨îËÆ∞Â∞ÜÊï¥Âêà‰∏∫‰∏Ä‰∏™Êñá‰ª∂Ôºâ

	-- isCompression : ÊòØÂê¶ÈúÄË¶ÅÊâìÂåÖÂéãÁº©ÔºåÈÄâÊã©‰∏ãÂàó‰∏§‰∏™ÈÄâÈ°π‰∏≠ÁöÑÂÖ∂‰∏≠‰∏Ä‰∏™
						true  ÔºöÊòØ
						false ÔºöÂê¶

	2. BV ÔºöÊåáÂÆöËßÜÈ¢ëBVÂè∑

	3. ÊúâÂá†ÁÇπÈúÄË¶ÅÊ≥®ÊÑè
		a. Âª∫ËÆÆ‰∏çË¶Å‰ΩøÁî®ÊïèÊÑüÁ¨¶Âè∑ÔºåÂê¶ÂàôÂÆπÊòìËØ≠Ê≥ïÂÜ≤Á™Å
		b. Èô§‰∫Ü pattern È°πÂ§ñÔºåÂÖ∂‰ªñÈÄâÈ°π‰∏≠ÁöÑÁ¨¶Âè∑ÁöÜ‰∏∫Ëã±ÊñáÁ¨¶Âè∑
		c. Èô§‰∫Ü true Âíå falseÔºåÂÖ∂‰ªñÁöÑÂÄº‰∏ÄÂÆöÊòØÊúâ‰∏ÄÂØπËã±ÊñáÁöÑÂèåÂºïÂè∑ÂåÖÊã¨ÁùÄ

*/
// ÈªòËÆ§ isOnlyCurr    Ôºöfalse
// ÈªòËÆ§ catalogStyle  Ôºö"È£éÊ†º‰∏Ä"
// ÈªòËÆ§ lineBreak     Ôºö"  "
// ÈªòËÆ§ titlePattern  Ôºö"P{x} üì∫ {xxx}"
// ÈªòËÆ§ lineBreak     Ôºö"\n"
// ÈªòËÆ§ bold          Ôºö"**"
// ÈªòËÆ§ italic        Ôºö"*"
// ÈªòËÆ§ list          Ôºö"-"
// ÈªòËÆ§ code          Ôºö"```"
// ÈªòËÆ§ isWiki        Ôºöfalse
// ÈªòËÆ§ isSeparate    Ôºöfalse
// ÈªòËÆ§ isCompression : false
var option = {
	isOnlyCurr: null,
	catalog: {
		style: null,
		lineBreak: null
	},
	title: {
		pattern: null,
		level: null
	},
	note: {
		escapeStyle: {
			lineBreak: null,
			bold: null,
			italic: null,
			list: null,
			code: null
		}
	},
	isWiki: null,
	isSeparate: null,
	isCompression: null
};
var BV = null;

var bili = new Ji_iL(null, null);
bili.toNote();
bili = null;
